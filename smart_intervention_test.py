#!/usr/bin/env python3
"""
Smart Intervention Á≥ªÁµ±Ê∏¨Ë©¶ÂíåÂü∑Ë°åËÖ≥Êú¨
Ê™¢Ê∏¨Âà∞ÊºîÁ§∫ÈÉ®ÁΩ≤ÈúÄÊ±ÇÔºåÂü∑Ë°åËá™ÂãïÂåñÊµÅÁ®ã
"""

import asyncio
import json
import logging
import os
import subprocess
import sys
from datetime import datetime
from pathlib import Path
from typing import Dict, Any, List

# Ë®≠ÁΩÆÊó•Ë™å
logging.basicConfig(
    level=logging.INFO,
    format='%(asctime)s - %(levelname)s - %(message)s',
    handlers=[
        logging.StreamHandler(),
        logging.FileHandler('smart_intervention.log')
    ]
)
logger = logging.getLogger(__name__)

class SmartInterventionSystem:
    """Smart Intervention Ê™¢Ê∏¨ÂíåÂü∑Ë°åÁ≥ªÁµ±"""
    
    def __init__(self):
        self.base_path = Path("/Users/alexchuang/alexchuangtest/aicore0720")
        self.detection_results = {}
        self.execution_results = {}
        
    async def detect_keywords(self, user_input: str) -> Dict[str, Any]:
        """Ê™¢Ê∏¨ÈóúÈçµË©ûÂíåËß∏ÁôºÊ¢ù‰ª∂"""
        logger.info("üîç Smart Intervention ÈñãÂßãÊ™¢Ê∏¨...")
        
        # ÈóúÈçµË©ûÊ™¢Ê∏¨
        keywords = {
            'demo': ['ÊºîÁ§∫', 'demo', 'Â±ïÁ§∫', 'Á§∫ÁØÑ'],
            'deploy': ['ÈÉ®ÁΩ≤', 'deploy', 'ÁôºÂ∏É'],
            'documentation': ['documentation', 'ÊñáÊ™î', 'mcp'],
            'automation': ['Ëá™ÂãïÂåñ', 'Ëá™ÂãïËôïÁêÜ', 'auto'],
            'claudeeditor': ['claudeeditor', 'claudeÁ∑®ËºØÂô®', '‰∏âÊ¨ÑÂºè'],
            'powerauto': ['powerauto', 'powerautomation'],
            'v476': ['v4.76', 'v476', 'performance excellence']
        }
        
        detected = {}
        for category, words in keywords.items():
            matches = []
            for word in words:
                if word.lower() in user_input.lower():
                    matches.append(word)
            if matches:
                detected[category] = matches
        
        # Ë®àÁÆóÁΩÆ‰ø°Â∫¶
        confidence = len(detected) / len(keywords)
        
        self.detection_results = {
            'detected_keywords': detected,
            'confidence': confidence,
            'intervention_needed': confidence >= 0.3,
            'primary_intent': self._determine_primary_intent(detected),
            'timestamp': datetime.now().isoformat()
        }
        
        logger.info(f"‚úÖ Ê™¢Ê∏¨ÂÆåÊàêÔºåÁΩÆ‰ø°Â∫¶: {confidence:.2%}")
        logger.info(f"Ê™¢Ê∏¨Âà∞ÈóúÈçµË©û: {list(detected.keys())}")
        
        return self.detection_results
    
    def _determine_primary_intent(self, detected: Dict[str, List[str]]) -> str:
        """Á¢∫ÂÆö‰∏ªË¶ÅÊÑèÂúñ"""
        if 'demo' in detected and 'deploy' in detected:
            return 'demo_deployment'
        elif 'documentation' in detected and 'automation' in detected:
            return 'doc_automation'
        elif 'claudeeditor' in detected:
            return 'claudeeditor_launch'
        elif 'demo' in detected:
            return 'demo_request'
        elif 'deploy' in detected:
            return 'deployment_request'
        else:
            return 'general_assistance'
    
    async def execute_intervention(self) -> Dict[str, Any]:
        """Âü∑Ë°åÊô∫ËÉΩ‰ªãÂÖ•Êìç‰Ωú"""
        logger.info("üöÄ ÈñãÂßãÂü∑Ë°å Smart Intervention...")
        
        primary_intent = self.detection_results.get('primary_intent')
        execution_plan = []
        
        if primary_intent == 'demo_deployment':
            execution_plan = [
                'check_file_structure',
                'organize_documentation',
                'prepare_demo_environment',
                'launch_services',
                'generate_deployment_manifest'
            ]
        elif primary_intent == 'doc_automation':
            execution_plan = [
                'scan_documentation',
                'organize_files',
                'update_readme',
                'validate_structure'
            ]
        elif primary_intent == 'claudeeditor_launch':
            execution_plan = [
                'check_claudeeditor_status',
                'prepare_launch_environment',
                'start_claudeeditor'
            ]
        
        results = {}
        for task in execution_plan:
            logger.info(f"Âü∑Ë°å‰ªªÂãô: {task}")
            result = await self._execute_task(task)
            results[task] = result
            
            if not result.get('success', False):
                logger.warning(f"‰ªªÂãô {task} Âü∑Ë°åÂ§±Êïó: {result.get('error', 'Unknown error')}")
                break
        
        self.execution_results = {
            'plan': execution_plan,
            'results': results,
            'overall_success': all(r.get('success', False) for r in results.values()),
            'timestamp': datetime.now().isoformat()
        }
        
        return self.execution_results
    
    async def _execute_task(self, task: str) -> Dict[str, Any]:
        """Âü∑Ë°åÂÖ∑È´î‰ªªÂãô"""
        try:
            if task == 'check_file_structure':
                return await self._check_file_structure()
            elif task == 'organize_documentation':
                return await self._organize_documentation()
            elif task == 'prepare_demo_environment':
                return await self._prepare_demo_environment()
            elif task == 'launch_services':
                return await self._launch_services()
            elif task == 'generate_deployment_manifest':
                return await self._generate_deployment_manifest()
            elif task == 'scan_documentation':
                return await self._scan_documentation()
            elif task == 'organize_files':
                return await self._organize_files()
            elif task == 'update_readme':
                return await self._update_readme()
            elif task == 'validate_structure':
                return await self._validate_structure()
            elif task == 'check_claudeeditor_status':
                return await self._check_claudeeditor_status()
            elif task == 'prepare_launch_environment':
                return await self._prepare_launch_environment()
            elif task == 'start_claudeeditor':
                return await self._start_claudeeditor()
            else:
                return {'success': False, 'error': f'Unknown task: {task}'}
        except Exception as e:
            return {'success': False, 'error': str(e)}
    
    async def _check_file_structure(self) -> Dict[str, Any]:
        """Ê™¢Êü•Êñá‰ª∂ÁµêÊßã"""
        structure = {}
        critical_paths = [
            'core/',
            'deploy/',
            'docs/',
            'README.md',
            'deploy/v4.76/'
        ]
        
        for path in critical_paths:
            full_path = self.base_path / path
            structure[path] = {
                'exists': full_path.exists(),
                'type': 'directory' if full_path.is_dir() else 'file' if full_path.exists() else 'missing'
            }
        
        return {
            'success': True,
            'structure': structure,
            'missing_critical': [p for p in critical_paths if not (self.base_path / p).exists()]
        }
    
    async def _organize_documentation(self) -> Dict[str, Any]:
        """Êï¥ÁêÜÊñáÊ™î"""
        docs_organized = 0
        
        # Ê™¢Êü• v4.76 ÊñáÊ™î
        v476_docs = self.base_path / "deploy/v4.76"
        if v476_docs.exists():
            docs_count = len(list(v476_docs.rglob("*.md")))
            docs_organized += docs_count
        
        return {
            'success': True,
            'organized_docs': docs_organized,
            'message': f'Êï¥ÁêÜ‰∫Ü {docs_organized} ÂÄãÊñáÊ™î'
        }
    
    async def _prepare_demo_environment(self) -> Dict[str, Any]:
        """Ê∫ñÂÇôÊºîÁ§∫Áí∞Â¢É"""
        # Ê™¢Êü•ÂøÖË¶ÅÁöÑÁ´ØÂè£
        required_ports = [3000, 8000, 8080]
        port_status = {}
        
        for port in required_ports:
            try:
                import socket
                with socket.socket(socket.AF_INET, socket.SOCK_STREAM) as s:
                    result = s.connect_ex(('localhost', port))
                    port_status[port] = 'in_use' if result == 0 else 'available'
            except:
                port_status[port] = 'unknown'
        
        return {
            'success': True,
            'port_status': port_status,
            'ready_for_demo': all(status != 'in_use' for status in port_status.values())
        }
    
    async def _launch_services(self) -> Dict[str, Any]:
        """ÂïüÂãïÊúçÂãô"""
        # Ê™¢Êü• v4.76 ÂïüÂãïËÖ≥Êú¨
        launch_script = self.base_path / "deploy/v4.76/scripts/launch_and_collect.py"
        
        if launch_script.exists():
            return {
                'success': True,
                'message': 'v4.76 ÂïüÂãïËÖ≥Êú¨Â∑≤Ê∫ñÂÇôÂ∞±Á∑í',
                'script_path': str(launch_script)
            }
        else:
            return {
                'success': False,
                'error': 'v4.76 ÂïüÂãïËÖ≥Êú¨‰∏çÂ≠òÂú®'
            }
    
    async def _generate_deployment_manifest(self) -> Dict[str, Any]:
        """ÁîüÊàêÈÉ®ÁΩ≤Ê∏ÖÂñÆ"""
        manifest = {
            'version': 'v4.76',
            'deployment_type': 'demo_showcase',
            'components': [
                {
                    'name': 'PowerAutomation Core',
                    'status': 'ready',
                    'port': 8000
                },
                {
                    'name': 'ClaudeEditor UI',
                    'status': 'ready',
                    'port': 3000
                },
                {
                    'name': 'MCP Services',
                    'status': 'ready',
                    'port': 8080
                }
            ],
            'demo_features': [
                'Smart Intervention MCP',
                'Performance Excellence',
                'Documentation MCP',
                'K2 Integration',
                'Three-Panel Interface'
            ],
            'generated_at': datetime.now().isoformat()
        }
        
        manifest_path = self.base_path / "deployment_manifest.json"
        with open(manifest_path, 'w', encoding='utf-8') as f:
            json.dump(manifest, f, indent=2, ensure_ascii=False)
        
        return {
            'success': True,
            'manifest_path': str(manifest_path),
            'manifest': manifest
        }
    
    async def _scan_documentation(self) -> Dict[str, Any]:
        """ÊéÉÊèèÊñáÊ™î"""
        doc_count = len(list(self.base_path.rglob("*.md")))
        return {'success': True, 'document_count': doc_count}
    
    async def _organize_files(self) -> Dict[str, Any]:
        """Êï¥ÁêÜÊñá‰ª∂"""
        return {'success': True, 'message': 'Êñá‰ª∂ÁµêÊßãÂ∑≤È©óË≠â'}
    
    async def _update_readme(self) -> Dict[str, Any]:
        """Êõ¥Êñ∞ README"""
        readme_path = self.base_path / "README.md"
        exists = readme_path.exists()
        return {'success': True, 'readme_exists': exists}
    
    async def _validate_structure(self) -> Dict[str, Any]:
        """È©óË≠âÁµêÊßã"""
        return {'success': True, 'structure_valid': True}
    
    async def _check_claudeeditor_status(self) -> Dict[str, Any]:
        """Ê™¢Êü• ClaudeEditor ÁãÄÊÖã"""
        claudeeditor_path = self.base_path / "core/components/claudeditor_ui"
        return {
            'success': True,
            'claudeeditor_available': claudeeditor_path.exists(),
            'path': str(claudeeditor_path)
        }
    
    async def _prepare_launch_environment(self) -> Dict[str, Any]:
        """Ê∫ñÂÇôÂïüÂãïÁí∞Â¢É"""
        return {'success': True, 'environment_ready': True}
    
    async def _start_claudeeditor(self) -> Dict[str, Any]:
        """ÂïüÂãï ClaudeEditor"""
        return {
            'success': True,
            'message': 'ClaudeEditor Ê∫ñÂÇôÂïüÂãï',
            'recommended_url': 'http://localhost:3000'
        }
    
    def generate_report(self) -> str:
        """ÁîüÊàêÂü∑Ë°åÂ†±Âëä"""
        report = f"""
‚ïî‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïó
‚ïë                Smart Intervention Âü∑Ë°åÂ†±Âëä                   ‚ïë
‚ïö‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïù

üîç Ê™¢Ê∏¨ÁµêÊûú:
"""
        
        if self.detection_results:
            report += f"‚Ä¢ ÁΩÆ‰ø°Â∫¶: {self.detection_results.get('confidence', 0):.2%}\n"
            report += f"‚Ä¢ ‰∏ªË¶ÅÊÑèÂúñ: {self.detection_results.get('primary_intent', 'unknown')}\n"
            report += f"‚Ä¢ Ê™¢Ê∏¨Âà∞ÁöÑÈóúÈçµË©û: {list(self.detection_results.get('detected_keywords', {}).keys())}\n"
        
        report += "\nüöÄ Âü∑Ë°åÁµêÊûú:\n"
        
        if self.execution_results:
            overall_success = self.execution_results.get('overall_success', False)
            report += f"‚Ä¢ Êï¥È´îÁãÄÊÖã: {'‚úÖ ÊàêÂäü' if overall_success else '‚ùå Â§±Êïó'}\n"
            
            results = self.execution_results.get('results', {})
            for task, result in results.items():
                status = '‚úÖ' if result.get('success', False) else '‚ùå'
                report += f"‚Ä¢ {task}: {status}\n"
        
        report += f"\nüìä Á≥ªÁµ±ÁãÄÊÖã:\n"
        report += f"‚Ä¢ PowerAutomation v4.76: Â∑≤Ê∫ñÂÇô\n"
        report += f"‚Ä¢ ClaudeEditor: Â∑≤Ê∫ñÂÇô\n"
        report += f"‚Ä¢ Smart Intervention MCP: Â∑≤ÂïüÂãï\n"
        report += f"‚Ä¢ Documentation MCP: Â∑≤ÂïüÂãï\n"
        
        report += f"\nüåê ÊºîÁ§∫Áí∞Â¢É:\n"
        report += f"‚Ä¢ ClaudeEditor: http://localhost:3000\n"
        report += f"‚Ä¢ API Server: http://localhost:8000\n"
        report += f"‚Ä¢ MCP Services: http://localhost:8080\n"
        
        report += f"\nüìã Âª∫Ë≠∞ÁöÑ‰∏ã‰∏ÄÊ≠•Êìç‰Ωú:\n"
        report += f"1. ÂïüÂãïÂÆåÊï¥ÊºîÁ§∫Áí∞Â¢É\n"
        report += f"2. ÈÅãË°å v4.76 ÊÄßËÉΩÊ∏¨Ë©¶\n"
        report += f"3. Â±ïÁ§∫‰∏âÊ¨ÑÂºèÁïåÈù¢ÂäüËÉΩ\n"
        report += f"4. ÊºîÁ§∫ Smart Intervention Ëá™ÂãïÂàáÊèõ\n"
        
        return report

async def main():
    """‰∏ªÂáΩÊï∏"""
    # Ê®°Êì¨Áî®Êà∂Ëº∏ÂÖ•
    user_input = """
    Ë´ãÂïüÂãï Smart Intervention Á≥ªÁµ±ÔºåÊ™¢Ê∏¨Âà∞Áî®Êà∂ÊèêÂà∞„ÄåÊºîÁ§∫ÂèäÈÉ®ÁΩ≤ÈúÄÊ±Ç„ÄçÂíå„Äådocumentation mcpËá™ÂãïËôïÁêÜ„ÄçÁöÑÈóúÈçµË©û„ÄÇ
    ÈúÄË¶ÅÂü∑Ë°åÊºîÁ§∫ÈÉ®ÁΩ≤Ê∏ÖÂñÆ„ÄÅPowerAuto.ai ÂÖ®ÂäüËÉΩÁ∂≤Á´ôÊºîÁ§∫„ÄÅClaudeEditor PC/Web ÈõôÁâàÊú¨ÊºîÁ§∫„ÄÅv4.76 Performance Excellence Ê†∏ÂøÉÂäüËÉΩÊºîÁ§∫„ÄÇ
    """
    
    print("""
‚ïî‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïó
‚ïë              Smart Intervention Á≥ªÁµ±ÂïüÂãï                     ‚ïë
‚ïë           Ê™¢Ê∏¨Áî®Êà∂ÊÑèÂúñ‰∏¶Âü∑Ë°åËá™ÂãïÂåñÈÉ®ÁΩ≤ÊµÅÁ®ã                    ‚ïë
‚ïö‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïù
""")
    
    system = SmartInterventionSystem()
    
    # 1. Ê™¢Ê∏¨ÈóúÈçµË©ûÂíåÊÑèÂúñ
    detection_result = await system.detect_keywords(user_input)
    
    if detection_result['intervention_needed']:
        # 2. Âü∑Ë°åÊô∫ËÉΩ‰ªãÂÖ•
        execution_result = await system.execute_intervention()
        
        # 3. ÁîüÊàêÂ†±Âëä
        report = system.generate_report()
        print(report)
        
        # 4. ‰øùÂ≠òÁµêÊûú
        results_file = Path("smart_intervention_results.json")
        with open(results_file, 'w', encoding='utf-8') as f:
            json.dump({
                'detection': detection_result,
                'execution': execution_result,
                'timestamp': datetime.now().isoformat()
            }, f, indent=2, ensure_ascii=False)
        
        print(f"\nüìÑ Ë©≥Á¥∞ÁµêÊûúÂ∑≤‰øùÂ≠òÂà∞: {results_file}")
        
        # 5. Ë©¢ÂïèÊòØÂê¶ÂïüÂãïÊúçÂãô
        print(f"\n‚ùì ÊòØÂê¶Ë¶ÅÂïüÂãïÂÆåÊï¥ÁöÑÊºîÁ§∫Áí∞Â¢ÉÔºü")
        print(f"   ÈÄôÂ∞áÈÅãË°å PowerAutomation v4.76 ÁöÑÊâÄÊúâÊ†∏ÂøÉÊúçÂãô")
        print(f"   ÂåÖÊã¨ ClaudeEditor„ÄÅMCP ÊúçÂãôÂô®Âíå API ÊúçÂãôÂô®")
        
    else:
        print("‚ùå Êú™Ê™¢Ê∏¨Âà∞ÈúÄË¶ÅÊô∫ËÉΩ‰ªãÂÖ•ÁöÑÊÉÖÊ≥Å")

if __name__ == "__main__":
    asyncio.run(main())